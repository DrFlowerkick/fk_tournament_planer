//! Concurrency tests for the PostalAddress DB adapter.
//!
//! Scope P2 (Concurrency):
//!   1) Two parallel updates starting from the same version (v0) -> exactly one wins (Optimistic Lock).
//!   2) Two parallel saves to the same ID from v0 -> one wins, the other hits Optimistic Lock.
//!
//! Notes:
//!   - Same mask as in `basis.rs`: TestDb/init, adapter access, common helpers.
//!   - No custom traits, no unknown utilities.
//!   - Comments are in English per project convention.

use anyhow::Result;
use app_core::{DbError, DbpPostalAddress};
use integration_testing::db_postgres_test_support::{common::*, postal_address::*};
use tokio::sync::Barrier;

#[tokio::test(flavor = "multi_thread")]
async fn given_two_parallel_updates_from_v0_then_only_one_succeeds_and_version_is_1() -> Result<()>
{
    // Arrange: fresh DB + seed v0
    init_db_testing();
    let tdb = TestDb::new().await?;
    let db = tdb.adapter();

    let v0 = db
        .save_postal_address(&make_new_address("concurrency-u1"))
        .await?;
    assert_eq!(v0.get_version(), Some(0));
    let id = v0.get_id().expect("id must be present");

    // Prepare two competing updates from the SAME v0 snapshot.
    // Using two different mutations helps verify the final winner semantically.
    let candidate_a = mutate_address_v2(v0.clone());
    let candidate_b = mutate_address_v3(v0.clone());

    // Coordinate near-simultaneous start
    let barrier = std::sync::Arc::new(Barrier::new(2));
    let b1 = barrier.clone();
    let b2 = barrier.clone();

    let db1 = db.clone();
    let candidate_a2 = candidate_a.clone();
    let h1 = tokio::spawn(async move {
        b1.wait().await;
        db1.save_postal_address(&candidate_a2).await
    });

    let db2 = db.clone();
    let candidate_b2 = candidate_b.clone();
    let h2 = tokio::spawn(async move {
        b2.wait().await;
        db2.save_postal_address(&candidate_b2).await
    });

    // Act
    let r1 = h1.await.expect("task1 panicked");
    let r2 = h2.await.expect("task2 panicked");

    // Assert: exactly one update succeeds
    let ok_count = (r1.is_ok() as u8) + (r2.is_ok() as u8);
    assert_eq!(ok_count, 1, "exactly one concurrent update must succeed");

    // Winner must be version 1 on same ID
    if let Ok(winner) = r1.as_ref().or(r2.as_ref()) {
        assert_eq!(winner.get_id(), Some(id));
        assert_eq!(winner.get_version(), Some(1));
    }

    // Loser must be optimistic lock domain error
    let loser_err = r1.err().or(r2.err()).expect("one loser error expected");
    assert!(matches!(loser_err, DbError::OptimisticLockConflict));

    // Final state: version == 1 and content equals exactly one of the candidates
    let fetched = db.get_postal_address(id).await?.expect("row must exist");
    assert_eq!(fetched.get_version(), Some(1));
    let equals_a = same_semantics(&fetched, &candidate_a);
    let equals_b = same_semantics(&fetched, &candidate_b);
    assert!(
        equals_a ^ equals_b,
        "final content must match exactly one winner (A xor B)"
    );

    Ok(())
}

#[tokio::test(flavor = "multi_thread")]
async fn given_two_parallel_inserts_same_name_zip_city_then_only_one_succeeds_unique_violation_for_loser()
-> Result<()> {
    // Arrange: fresh DB
    init_db_testing();
    let tdb = TestDb::new().await?;
    let db = tdb.adapter();

    // Build two *New* addresses that share the same (name, postal_code, locality).
    // UUIDs are generated by the DB, so we don't touch the id.
    let new_a = make_new_address("concurrency-insert");
    let new_b = new_a.clone();
    let third = new_a.clone();

    // Coordinate near-simultaneous inserts.
    let barrier = std::sync::Arc::new(Barrier::new(2));
    let b1 = barrier.clone();
    let b2 = barrier.clone();

    let db1 = db.clone();
    let h1 = tokio::spawn(async move {
        b1.wait().await;
        db1.save_postal_address(&new_a).await
    });

    let db2 = db.clone();
    let h2 = tokio::spawn(async move {
        b2.wait().await;
        db2.save_postal_address(&new_b).await
    });

    // Act
    let r1 = h1.await.expect("task1 panicked");
    let r2 = h2.await.expect("task2 panicked");

    // Assert: exactly one insert must succeed
    let ok_count = (r1.is_ok() as u8) + (r2.is_ok() as u8);
    assert_eq!(
        ok_count, 1,
        "exactly one parallel insert must succeed for the same (name, zip, city)"
    );

    // Loser should map to UniqueViolation (partial unique index hit). Be tolerant if mapper differs.
    let loser_err = r1.err().or(r2.err()).expect("one loser error expected");
    assert!(matches!(loser_err, DbError::UniqueViolation(_)));

    // a *third* insert with the same triplet must also fail.
    let third_res = db
        .save_postal_address(&third)
        .await
        .expect_err("third must result in error.");
    assert!(matches!(third_res, DbError::UniqueViolation(_)));

    Ok(())
}
